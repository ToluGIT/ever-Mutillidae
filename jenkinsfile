pipeline {
    agent any

    environment {
        REPO_URL = 'https://github.com/ToluGIT/ever-Mutillidae.git'
        BRANCH = 'main'
        IMAGE_PREFIX = 'toluid'
        AWS_REGION = 'us-east-1' // Update to your AWS region
    }

    stages {
        stage('Retrieve Secrets from AWS Secrets Manager') {
            steps {
                script {
                    // Retrieve DockerHub credentials
                    def dockerHubCreds = sh(script: "aws secretsmanager get-secret-value --secret-id DockerHubCredentials --region ${AWS_REGION} --query 'SecretString' --output text", returnStdout: true)
                    def dockerHubSecret = readJSON(text: dockerHubCreds)
                    env.DOCKER_USR = dockerHubSecret.username
                    env.DOCKER_PWD = dockerHubSecret.password

                    // Retrieve EC2 SSH Key from Secrets Manager (recommended over password)
                    def ec2Creds = sh(script: "aws secretsmanager get-secret-value --secret-id EC2InstanceCredentials --region ${AWS_REGION} --query 'SecretString' --output text", returnStdout: true)
                    def ec2Secret = readJSON(text: ec2Creds)
                    env.EC2_USER = ec2Secret.username
                    // Store SSH key in temporary file for secure authentication
                    writeFile file: 'ec2-key.pem', text: ec2Secret.ssh_private_key
                    sh 'chmod 600 ec2-key.pem'

                    // Retrieve SonarCloud credentials
                    def sonarCreds = sh(script: "aws secretsmanager get-secret-value --secret-id SonarCloudCredentials --region ${AWS_REGION} --query 'SecretString' --output text", returnStdout: true)
                    def sonarSecret = readJSON(text: sonarCreds)
                    env.SONAR_TOKEN = sonarSecret.token
                    env.SONAR_PROJECT_KEY = sonarSecret.project_key
                    env.SONAR_ORGANIZATION = sonarSecret.organization

                    // Retrieve Server IP
                    def serverIpSecret = sh(script: "aws secretsmanager get-secret-value --secret-id ServerIP --region ${AWS_REGION} --query 'SecretString' --output text", returnStdout: true)
                    env.SERVER_IP = readJSON(text: serverIpSecret).ip_address
                }
            }
        }

        stage('Checkout Code') {
            steps {
                script {
                    git branch: "${BRANCH}", url: "${REPO_URL}"
                    GIT_COMMIT = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
                    echo "GIT_COMMIT is set to ${GIT_COMMIT}"
                }
            }
        }

        stage('SonarCloud SAST Analysis') {
            steps {
                withEnv(["PATH=/usr/local/sonar-scanner/bin:$PATH"]) {
                    sh '''
                    sonar-scanner \
                      -Dsonar.organization=${SONAR_ORGANIZATION} \
                      -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
                      -Dsonar.sources=. \
                      -Dsonar.host.url=https://sonarcloud.io \
                      -Dsonar.login=${SONAR_TOKEN}
                    '''
                }
            }
        }

        stage('Build Docker Images') {
            steps {
                script {
                    // Build images - www container needs DATABASE_PASSWORD as build arg
                    sh """
                    # Build images with required build arguments
                    docker compose -f .build/docker-compose.yml build \
                      --build-arg DATABASE_PASSWORD=mutillidae
                    """
                }
            }
        }

        stage('Trivy Image Scanning') {
            steps {
                script {
                    sh 'mkdir -p trivy-reports'
                    def images = ['database', 'database_admin', 'www', 'ldap', 'ldap_admin']

                    for (image in images) {
                        def imageName = "${IMAGE_PREFIX}:${image}"
                        def reportFile = "trivy-reports/${image}-scan.json"

                        def imageExists = sh(
                            script: "docker images -q ${imageName}",
                            returnStatus: true
                        ) == 0

                        if (imageExists) {
                            echo "Scanning ${imageName} with Trivy..."
                            sh """
                            trivy image --severity HIGH,CRITICAL --format json --output ${reportFile} ${imageName} || true
                            """
                        } else {
                            echo "Image ${imageName} not found locally. Skipping Trivy scan."
                        }
                    }
                }
            }
        }

        stage('Tag and Push Docker Images to Docker Hub') {
            steps {
                script {
                    def versionTag = "v${env.BUILD_NUMBER}-${GIT_COMMIT}"
                    def services = ['database', 'database_admin', 'www', 'ldap', 'ldap_admin']

                    // Log in to Docker Hub securely using environment variables without exposing password in logs
                    sh '''
                    echo "${DOCKER_PWD}" | docker login -u "${DOCKER_USR}" --password-stdin
                    '''

                    for (service in services) {
                        def imageName = "${IMAGE_PREFIX}:${service}"
                        def versionedTag = "${DOCKER_USR}/${service}:${versionTag}"

                        echo "Tagging ${imageName} as ${versionedTag}..."

                        def image_id = sh(
                            script: "docker images ${imageName} --format '{{.ID}}' | head -n 1",
                            returnStdout: true
                        ).trim()

                        if (image_id) {
                            sh """
                            docker tag ${image_id} ${versionedTag}
                            docker push ${versionedTag}
                            """
                        } else {
                            echo "Warning: Image ${imageName} was not built successfully and will be skipped."
                        }
                    }

                    // Log out after pushing images
                    sh 'docker logout'
                }
            }
        }

        stage('Deploy to Minikube on EC2') {
            steps {
                script {
                    def imageTag = "v${env.BUILD_NUMBER}-${GIT_COMMIT}"

                    // Create deployment files with image tags and deploy
                    sh """
                    # Copy k8s files to workspace and update image placeholders
                    cp -r k8s/ k8s-deploy/
                    
                    # Update image placeholders with actual image tags
                    sed -i 's|IMAGE_PLACEHOLDER|docker.io/toluid/database:${imageTag}|g' k8s-deploy/database-deployment.yaml
                    sed -i 's|IMAGE_PLACEHOLDER|docker.io/toluid/www:${imageTag}|g' k8s-deploy/www-deployment.yaml
                    sed -i 's|IMAGE_PLACEHOLDER|docker.io/toluid/ldap:${imageTag}|g' k8s-deploy/ldap-deployment.yaml
                    sed -i 's|IMAGE_PLACEHOLDER|docker.io/toluid/ldap_admin:${imageTag}|g' k8s-deploy/ldap_admin-deployment.yaml
                    sed -i 's|IMAGE_PLACEHOLDER|docker.io/toluid/database_admin:${imageTag}|g' k8s-deploy/database_admin-deployment.yaml
                    """

                    // Copy files to EC2 and deploy using declarative approach
                    sh """
                    # Copy k8s files to remote server using SSH key
                    scp -i ec2-key.pem -o StrictHostKeyChecking=no -r k8s-deploy/ "${EC2_USER}"@${SERVER_IP}:/tmp/
                    
                    # Deploy using kubectl apply with SSH key
                    ssh -i ec2-key.pem -o StrictHostKeyChecking=no "${EC2_USER}"@${SERVER_IP} << 'EOF'
                    echo "Deploying to Kubernetes on Minikube with image tag: ${imageTag}"
                    
                    # Apply secrets and configmaps first
                    kubectl apply -f /tmp/k8s-deploy/secrets.yaml
                    
                    # Apply deployments and services
                    kubectl apply -f /tmp/k8s-deploy/
                    
                    # Clean up
                    rm -rf /tmp/k8s-deploy/
                    EOF
                    """
                }
            }
        }

        stage('Health Check and Validation') {
            steps {
                script {
                    // Wait for deployments to be ready and validate
                    sh """
                    ssh -i ec2-key.pem -o StrictHostKeyChecking=no "${EC2_USER}"@${SERVER_IP} << 'EOF'
                    echo "Waiting for deployments to be ready..."
                    
                    # Wait for all deployments to be ready (timeout 5 minutes)
                    kubectl wait --for=condition=available --timeout=300s deployment/database-deployment
                    kubectl wait --for=condition=available --timeout=300s deployment/www-deployment
                    kubectl wait --for=condition=available --timeout=300s deployment/directory-deployment
                    kubectl wait --for=condition=available --timeout=300s deployment/database-admin-deployment
                    kubectl wait --for=condition=available --timeout=300s deployment/directory-admin-deployment
                    
                    # Show deployment status
                    echo "Deployment Status:"
                    kubectl get deployments -o wide
                    kubectl get pods -o wide
                    kubectl get services
                    
                    # Basic connectivity test
                    echo "Testing internal connectivity..."
                    kubectl run test-pod --image=busybox --rm -it --restart=Never -- nslookup database-service
                    EOF
                    """
                }
            }
        }
    }

    post {
        always {
            echo 'Deployment completed. Check logs for details.'
            archiveArtifacts artifacts: 'trivy-reports/*.json', allowEmptyArchive: true
            // Clean up SSH key
            sh 'rm -f ec2-key.pem || true'
            // Clean up k8s-deploy directory
            sh 'rm -rf k8s-deploy/ || true'
        }
        success {
            echo 'Pipeline executed successfully!'
            echo 'All deployments are healthy and ready.'
        }
        failure {
            echo 'Pipeline failed. Check logs for more details.'
            // Get deployment status for troubleshooting
            sh """
            ssh -i ec2-key.pem -o StrictHostKeyChecking=no "${EC2_USER}"@${SERVER_IP} << 'EOF' || true
            echo "Deployment troubleshooting info:"
            kubectl get pods --all-namespaces
            kubectl describe pods -l app in (www,database,directory)
            kubectl logs -l app=www --tail=50
            EOF
            """ 
        }
    }
}
